## 站点模仿的蘑菇街

### 首页请求了轮播图的数据
* 导航 【 流行   新款   推荐】  点击切换展示不同的数据
* 导航做了顶部停留效果，原理是监听页面的滚动，当到达顶部的时候让导航栏定位属性改为fixed
* 考虑顶部停留脱离了文档流，因此本身让其套一个父盒子，父盒子相对定位  导航栏绝对定位,这样到时候变为  position:fiexd 时候不至于导致页面布局混乱
* 返回顶部也是通过监听 滚动事件  ,  然后通知他显示和隐藏，绑定点击事件，让页面返回顶部



### 详情页通过数据中的iid  ，向后台发送AJAX请求

* 详情页复用之前的首页轮播图的组件
* 详情页的页面数据比较复杂，请求的后台数据也比较复杂，因此在请求数据过来之后对数据进行一些过滤，在service 中定义一些类，通过 constructor 构造器将需要的数据整合，这样页面调用这个类，构造这个类的实例就能得到一个自己需要数据的实例了
* 由于需要详情页有加入购物车的操作，当用户点击加入购物车时候，这些数据该保存到一个cart页面也能轻松访问到的地方
* 因此app中创建全局的变量  globalCartData  ，详情页面中通过 getApp( )方法得到这个app实例
* 直接调用 app.globalCartData  拿到这个全局变量，此时就方便在detail和 cart中共同操作这些数据了



### 购物车界面数据是调用全局app得到的

* 页面做了全选和局部选的同步，为了方便，在加入购物车时候，控制局部按钮的开关的属性isChecked 已经定义好，进入购物车页面直接调用这个属性决定是否打钩即可，当然全选按钮的选中不选中是通过  每个小按钮 决定的，其中还包括价格的计算，所有isChecked 为true  的数据中的  price和count相乘  然后所有结果相加得到合计,
* 当然也做了增加减少件数，设置了最大99  最小1  当为1的时候再减的话会直接从app全局变量数据中删除该商品的数据，购物车页面也会同步
* 当然由于 微信小程序不能像 vue  那样使用filter 来对mustache中的数据进行操作
* 因此需要小程序官方提供的 wxs   外部定义工具栏，内部调用，对价格进行操作，保留两位小数



### 我的  

* 本身通过 getUserInfo({ }) 去获取用户的数据，然后渲染，但是微信官方关闭了这个通道
* 考虑到我们只是想要获取用户的数据进行一个展示
* 因此使用了 ```<open-data type="userAvatarUrl"></open-data>```   直接进行一些  头像，呢称，定位信息做一个展示
* 通过 wx.switchTab（{ }） 跳转路由到购物车



### 遇到的一些问题：

* 前期封装组件对应的一套数据，后期组件复用的时候结构后台数据结构不统一，导致组件无法直接使用，个别地方是通过拿到数据，然后修改数据使其符合之前的数据结构，然后再保存这个数据，再进行渲染，但是这样对性能影响很大
* 后续直接修改封装的组件，通过 wx:if     wx:else  方式当组件不满足一定条件时候换另一种获取数据的方式渲染，首页的推荐数据和分类的推荐数据就是这样操作的
* 后台个别详情页数据没有评论数据，或者直接iid访问不到详情数据的，为此做了一些优化，比如没有评论数据渲染的话，进行一个判断，没有评论数据就给评论属于一个空数组，这样就不会因为找不到这个评论数组对象程序出错
* iid直接访问不到数据的没有很好的办法解决，因为后台没有数据，通过promise ， catch一个错误信息，通过 wx.showToast({ title:"o(╥﹏╥)o"})  弹出一个错误信息，然后在通过wx.navigataBack({delta:1})  进行返回
* 分类界面的竖屏滚动，开始没给scroll-view 一个固定高度，每次都是滑动直接出发整个页面的滑动，给了一定高度又无法匹配每个手机，因此手机的高度有高有低 使用rpx也无法操作，每个手机的横竖占比不同，因此样式的时候直接给了100vh   解决了，测试发现100vh 是不包含顶部tabbar  和底部tabbar的区域，这样不仅解决了上面问题，还解决了之前高度给多了  拉倒底后再拉就会拉动整个页面的情况

 